## 0. OODP (Object-Oriented Design Pattern)

> OODP의 필요성:
> 일반적으로 자동차, 건물, 여러가지 체계 등등 일회용이 아닌 이상 모든 것에는 유지비용이라는 것이 드는데 이것은 소프트웨어도 해당된다.
> 
> 작은 어플리케이션을 유지하고, 보수하는 데 있어서도 꽤나 많은 비용이 드는데, 이러한 유지 비용은 유지해야 하는 것의 규모가 크면 클 수록 더 비싸지는 것이 당연하다.
> 
> 어떤 한 것을 통해 얻는 것 보다 그것을 유지하는 데 드는 비용이 더 크다면 그만큼의 손해가 발생하기 때문에 이것을 보다 값싸고, 손 쉽게 유지하기 위해서 필요한 것이 OODP이다.
> 
> OODP는 코드를 재사용 가능하게 디자인(객체지향)함으로써 보다 효율적이고 합리적인 프로그램을 만드는 것을 가능하게 해주는 객체지향적인 디자인 패턴을 의미한다.

### 0.1. 객체지향 프로그래밍(Object-Oriented Programming)이란?
> 
> 프로그래밍에서 필요한 데이터를 추상화(Abstraction)시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호 작용을 통해 로직을 구성하는 프로그래밍 방법이다.

### 0.2. 객체지향 vs 절차지향(Object-Oriented vs Procedural)
> 
> 흔히 객체지향과 상반되는 개념으로 절차지향을 꼽을 수 있다.
> 절차지향 프로그래밍이란 - 코드를 위에서 아래로 순차적으로 처리를 함으로써 프로그램 전체가 유기적으로 연결되도록 하는 프로그래밍을 의미하고, 이것은 컴퓨터의 연산구조와 유사하여 속도가 매우 빠르다는 장점이 있습니다.

### 0.2.1. 객체지향
> * 대표 언어: Java
> * 장점:
>   * 코드의 재사용성하기에 용이해서 유지, 보수가 쉽다.
>   * 절차지향 언어에 비해 인간의 언어와 좀 더 유사해서 코딩하기가 더 쉽다.
> * 단점:
>   * 절차지향에 비해 실행 속도가 느리다.
>   * 설계에 많은 시간이 소요된다.

### 0.2.2. 절차지향
> * 대표 언어: C
> * 장점:
>   * 실행속도가 빠르다.
> * 단점:
>   * 유지보수가 어렵다.
>   * 비효율적이다.
> 
> 추가적인 설명을 보태자면, 객체지향의 경우 모든 코드가 객체 단위로 나뉘어져 있기 때문에 으로 설계된 컴퓨터가 있다고 가정하고 이것을 수리를 해야 한다면, CPU, GPU, Power 등 부품(객체) 별로 성능 테스트나 결함 테스트 하기에 용이하다. 하지만, 절차지향의 경우, 컴퓨터 전체를 처음부터 끝까지 다 살펴봐야 한다는 차이가 있다. CPU가 문제라면 CPU만 교체하면 될텐데 절차지향은 모든 부품을 다 뜯어서 통째로 고쳐야 하기 때문에 유지비용이 많이 들 수 밖에 없고, 시간도 많이 소요되는 것이다.

### 0.3. Programming and Design in OO(Object-Oriented) Paradigm are
* two Distinct tasks - 구분되는 작업이다. 즉, 설계와 프로그래밍은 따로 구분된 다른 작업이다.
* however, <u>more tightly intertwined</u> than conventional Programming Paradigm
* requires a new way(OO) of thinking
  * through the use of desing patterns,
  * exploration of the design of Java Class Libraries,
  * iterative(incremental) software development
> 객체지향 패러다임에서 프로그래밍과 디자인이란
> * 2가지로 구분되는 작업이다. 즉, 설계와 프로그래밍은 따로 구분된 다른 작업이다.
> * 하지만 프로그래밍과 설계가 기존의 프로그래밍 패러다임에 비해 객체지향 패러다임에서는 훨씬 밀접하게 뒤얽혀 있다.
> * 객체지향이라는 새로운 사고방식이 요구된다.  
>   * 디자인 패턴,
>   * 자바의 클래스와 라이브러리에 대한 탐색,
>   * Iterative 소프트웨어 개발(기능을 하나씩 추가하는(incremental) - 지속적인 유지 보수)을 통해서 객체지향을 구현한다.

> 한 줄 요약
> * 기존 패러다임: 프로그램에 대한 전체 설계를 끝낸 후, 한 번에 개발하는 방식.
> * 객체지향(OO) 패러다임: 단계별로(기능별로) 설계를 한 후, 프로그램을 만들고, 다시 새로운 단계(기능)을 설계 후, 개발하는 방식.
> * 이러한 OODP의 구조는 단순히 자바의 문법과 Library를 배우는 것과는 차원이 다른 문제이다.

## 1. Design Patterns

생성 패턴
구조 패턴
행동 패턴
## 1.1. 싱글톤 패턴
  * Category: Creational dp
  * Intent: 전역으로 접근 가능한 인스턴스를 하나만 가지는 클래스를 만들게 하기 위해
  * Applicability: 클라이언트로 하여금 잘 알려진 엑세스 포인트에 엑세스 가능하게 한다.
  * Multithread Problem
    * singleton 클래스 내에서 instant 선언 시 초기화 방법
    * synchronized - getter & print에 각각 synchronized

## 1.2. 템플릿 메소드 패턴
  * Category: Behavioral dp
  * Intent: 특정 작업을 처리하는 일부분을 서브 클래스로 캡슐화하여 전체적인 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내용을 바꾸는 패턴
  * Applicability: 
    * 공통되는 코드는 부모클래스에 하나로 넣어놓고, 공통되지 않는 코드는 자식 클래스에서 overide를 통해 한 번씩만 사용되게 하고, 이를 통해 유지보수하는 데 유용하게 한다.
    * non-abstract: 공통 behavior
    * abstract: context-specific behavior
    * context마다 특정 behavior가 placeholder의 역할을 하고, 이것을 hook-method라고 한다.

* strategy 패턴
  * Category: Behavioral dp
  * Intent: 알고리즘들을 각각 캡슐화 하여, 서로 교체가능하게 한다. 
  * Applicability:
    * 동일한 문제를 다른 알고리즘으로 해결할 수 있게 한다.
    * abstract method: 각가의 전략 클래스에 선언되어있다.
    * context class에서 abstract method를 오버라이드한다.
    * 메소드들을 캡슐화를 통해 오브젝트처럼 사용하여 코드를 변경할 때 이것들만 변경하여서 확장에 용이하게 한다.
  * 객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 캡슐화 하는 인터페이스를 정의하여,
  * 객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법