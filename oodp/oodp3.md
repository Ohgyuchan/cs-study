### disjoint & complete
* disjoint
  * 자식 클래스가 동시에 두 클래스에 속할 수 없다. class A == a 이면서 class B == a 일 수 없다.
  * complete
    * parent의 객체는 반드시 자식 클래스 중 하나에 속한다.

* 일반화
  * 상호배타적
* 특수화
  * 자식 클래스가 2개 이상으로 나뉘면 그 클래스마다 특수한 근거(기능)가 있어야됨
* discriminator 변별자 : 인스턴스 분류 기준
* multiple classification 다중분류자 : 한 인스턴스가 동시에 여러 클래스에 속함

피터코드의 상속규칙
1. 자식클래스와 부모클래스 사이는 역할 수행 관계가 아니어야 한다.
2. 한 클래스의 인스턴스는 다른 서브 클래스의 객체로 변환할 필요가 절대 없어야 한다.
3. 자식 클래스가 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 한다.
4. 자식 클래스가 단지 일부 기능을 재사용할 목적으로 유틸리티 역할을 수행하는 클래스를 상속하지 않아야 한다.
5. 자식 클래스가 역할, 트랙잭션, 디바이스 등을 특수화 해야 한다.

Solid 원칙
다섯가지 기본 원칙
* S - 단일 책임 원칙
  * SRP
  * 한 클래스는 하나의 책임만 가져야 한다.
* O - 개방-폐쇄 원칙
  * OCP
  * 소프트웨어 요소는 확정에는 열려 있으나 변경에는 닫혀 있어야 한다.
  * 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계해야 한다.
  * 클래스를 변경하지 않고도 대상 클래스의 환경을 변경할 수 있도록 설계해야 한다.
* L - 리스코프 치환 원칙
  * LSP
  * 부모클래스와 자식클래스의 행위는 일관성이 있어야 한다.
  * 재정의 하지 않는 것이 LSP를 지키는 가장 쉬운 방법.
* I - 인터페이스 분리 원칙
  * ISP
  * 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
  * 인터페이스를 클라이언트에 특화되록 분리시키는 설계 원칙
  * 클라이언트가 사용하지 않는 기능에는 영향을 받지 않아야 한다.
* D - 의존관계 역전 원칙
  * DIP
  * 추상화에 의존해야지, 구체화에 의존하면 안된다.
  * 의존성 주입은 이 원칙을 따라는 방법 중 하나다.
  * 변화하기 어려운 것에 의존해야 한다.